module @ops

type Ordering = Less | Equal | Greater;

class Add a = infixl 6 (+): a -> a -> a;

class Sub a = infixl 6 (-): a -> a -> a;

class Mul a = infixl 7 (*): a -> a -> a;

class Div a =
    infixl 7 (/): a -> a -> a,
    infixl 7 (%): a -> a -> a,
;

class Pow a =
    infixr 8 (^): a -> int -> a,
    infixr 8 (^^): a -> real -> a,
;

class Neg a = prefix 10 (-): a -> a;

class Not a = prefix 10 (!): a -> bool;

class And a = infixr 3 (&&): a -> a -> bool;

class Or a = infixr 2 (||): a -> a -> bool;

class Eq a =
    infix 4 (==): a -> a -> bool,
    infix 4 (!=): a -> a -> bool,

    let (!=) a = (!) . (==) a,
;

class {Eq a} Cmp a =
    val cmp: a -> a -> Ordering,

    infix 4 (>):  a -> a -> bool,
    infix 4 (<):  a -> a -> bool,
    infix 4 (>=):  a -> a -> bool,
    infix 4 (<=):  a -> a -> bool,

    let (>) a b = match Cmp::cmp a b with
        Ordering::Greater -> true,
        _ -> false,
    ,

    let (<) a b = match Cmp::cmp a b with
        Ordering::Less -> true,
        _ -> false,
    ,

    let (<=) a b = match Cmp::cmp a b with
        Ordering::Less | Ordering::Equal -> true,
        _ -> false,
    ,

    let (>=) a b = match Cmp::cmp a b with
        Ordering::Greater | Ordering::Equal -> true,
        _ -> false,
    ,
;

class {Cmp a, Add a, Sub a, Mul a, Div a, Pow a, Neg a} 
    Number a = 
        val from_int: int -> a,
        val from_real: real -> a,
;

instance Eq Ordering =
    let (==) a b = match (a,b) with
        (Ordering::Less, Ordering::Less) 
        | (Ordering::Equal, Ordering::Equal) 
        | (Ordering::Greater, Ordering::Greater) -> true,
        _ -> false,
;

val {a, Cmp a} max: a -> a -> a;
let max x y = if x <= y then y else x;

val {a, Cmp a} min: a -> a -> a;
let min x y = if x <= y then x else y;
