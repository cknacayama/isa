module !result with {monad::*, result::Result::*}

type Result e a = Err e | Ok a;

instance {e} => Functor Result e =
    let fmap f res = match res with
        Ok a -> Ok $ f a,
        Err e -> Err e,
;

instance {e} => Applicative Result e =
    let pure = Ok,
    let apply f x = match (f,x) with
        (Ok f, Ok x) -> Ok $ f x,
        (Err e, _) |
        (_, Err e) -> Err e,
;

instance {e} => Monad Result e =
    let bind res f = match res with
        Ok a -> f a,
        Err e -> Err e,
;

