module @prelude with {
    option::_,
    result::_,
    monad::_,
    ops::_,
    list::_,
    string::_,
}

val real_to_int: real -> int;
val int_to_real: int -> real;
val {a} panic: String -> a;

val {a,b} const: a -> b -> a;
let const a _ = a;

val {a} id: a -> a;
let id a = a;

val {a, b, c} flip: (a -> b -> c) -> b -> a -> c;
let flip f x y = f y x;

infixr 0 {a, b} ($): (a -> b) -> a -> b;
let ($) f x = f x;

infixr 9 {a, b, c} (.): (b -> c) -> (a -> b) -> a -> c;
let (.) f g x = f (g x);

infixl 1 {a, b} (|>): a -> (a -> b) -> b;
let (|>) x f = f x;

instance Add int = let (+) a b = a + b;
instance Sub int = let (-) a b = a - b;
instance Mul int = let (*) a b = a * b;
instance Div int = 
    let (/) a b = a / b,
    let (%) a b = a % b,
;
instance Pow int =
    let (^) a b = a ^ b,
    let (^^) a b = a ^^ b,
;
instance Neg int = let (-) a = -a;
instance Eq int = let (==) a b = a == b;
instance Cmp int = 
    let cmp a b =
        if a == b then
            Ordering::Equal
        else if a > b then
            Ordering::Greater 
        else
            Ordering::Less
;
instance Number int = 
    let from_int a = a,
    let from_real a = real_to_int a,
;

instance Add real = let (+) a b = a + b;
instance Sub real = let (-) a b = a - b;
instance Mul real = let (*) a b = a * b;
instance Div real = 
    let (/) a b = a / b,
    let (%) a b = a % b,
;
instance Pow real =
    let (^) a b = a ^ b,
    let (^^) a b = a ^^ b,
;
instance Neg real = let (-) a = -a;
instance Eq real = let (==) a b = a == b;
instance Cmp real = 
    let cmp a b =
        if a == b then
            Ordering::Equal
        else if a > b then
            Ordering::Greater 
        else
            Ordering::Less
;
instance Number real = 
    let from_int a = int_to_real a,
    let from_real a = a,
;

instance And bool = let (&&) a b = a && b;
instance Or bool = let (||) a b = a || b;
instance Not bool = let (!) a = !a;

instance Eq char = let (==) a b = a == b;
instance Eq () = let (==) () () = true;
