module monad

type Option a = None | Some a;

val {a,b} => const: a -> b -> a;
let const a b = a;

class Functor f =
    val {a,b} => fmap: (a -> b) -> f a -> f b,
    val {a,b} => replace: a -> f b -> f a,

    let replace = Functor::fmap . const,
;

class {Functor f} => Applicative f =
    val {a} => pure: a -> f a,
    val {a,b} => apply: f (a -> b) -> f a -> f b,
;

class {Applicative f} => Monad f =
    val {a} => return: a -> f a,
    val {a,b} => bind: f a -> (a -> f b) -> f b,

    let return = Applicative::pure,
;

instance Functor Option =
    let fmap f opt = match opt with
        Option::Some a -> Option::Some (f a),
        Option::None -> Option::None,
;

instance Applicative Option =
    let pure = Option::Some,
    let apply f x = match (f,x) with
        (Option::Some f, Option::Some x) -> Option::Some (f x),
        _ -> Option::None,
;

instance Monad Option =
    let bind opt f = match opt with
        Option::Some a -> f a,
        Option::None -> Option::None,
;
