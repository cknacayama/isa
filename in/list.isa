module List
    type List a = Nil | Cons a (List a);
    
    val {a} => return: a -> List a;
    let return v = Cons v Nil;

    val {a} => lenght: List a -> int;
    let lenght list =
        match list with
            Nil -> 0,
            Cons _ list -> 1 + lenght list,
    ;

    val {a} => head: List a -> Option a;
    let head list =
        match list with
            Nil -> None,
            Cons v _ -> Some v,
        ;

    val {a} => tail: List a -> Option a;
    let tail list =
        match list with
            Nil -> None,
            Cons v Nil -> Some v,
            Cons _ rest -> tail rest,
        ;

module Option

    type Option a = None | Some a;

    val {a, b} => fmap: (a -> b) -> Option a -> Option b;
    let fmap f opt =
        match opt with
            Some a -> f a |> Option.return,
            None -> None,
        ;

    val {a} => Option.return: a -> Option a;
    let Option.return a = Some a;
    
    val {a, b} => Option.bind: Option a -> (a -> Option b) -> Option b;
    let Option.bind opt f = 
        match opt with
            Some a -> f a,
            None -> None,
        ;

// module Main
// 
//     class Eq a =
//         val eq: a -> a -> bool,
//         val ne: a -> a -> bool,
//     ;
// 
//     instance {a, Eq a} => Eq List.List a =
//        let eq a b =
//            match (a,b) with
//                (List.Cons v1 rest1, List.Cons v2 rest2) -> v1 = v2 && eq rest1 rest2,
//                (Nil, Nil) -> true,
//                _ -> false,
//     ;
